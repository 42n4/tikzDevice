/*
 *  tikzDevice, (C) 2009-2010 Charlie Sharpsteen and Cameron Bracken
 *
 *  A graphics device for R : 
 *    A Computer Language for Statistical Data Analysis
 *
 *  Copyright (C) 1995, 1996  Robert Gentleman and Ross Ihaka
 *  Copyright (C) 2001-8  The R Development Core Team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, a copy is available at
 *  http://www.r-project.org/Licenses/
 *
 *  The C code in this project started as a fork of:
 *    A PicTeX Device, (C) 1996 Valerio Aimale
 *
 *
 *  "If I have seen further, it is only by standing on 
 *   the shoulders of giants." 
 *
 *   -I. Newton
 *  
*/

/********************************************************************/

/*
 * NOTE:
 *   This is the first effort of dyed-in-the-wool Fortran programmers
 *   to write C code. Hence the comments in this file will make many
 *   observations that may seem obvious or inane. There also may be a
 *   generous amount of snide comments concerning the syntax of the 
 *   C language.
*/

/* 
 * Function prototypes are defined in here. Apparently in C
 * it is absolutely necessary for function definitions to appear 
 * BEFORE they are called by other functions. Hence many source code
 * files do not present code in the order in which that code
 * is used. Using a header file with function declarations allows
 * the programmer to order the code in any sequence they choose.
*/

/*
 * This header also includes other header files describing functions 
 * provided by the R language.
*/
#include "metapDevice.h"

// We are writing to files so we need stdio.h
#include <stdio.h>

/*
 * Main entry point from the R environment, called by the R function
 * tikz() to open a new MetaP graphics device.
*/
SEXP metapDevice ( SEXP args ){

  /*
   * Make sure the version number of the R running this
   * routine is compatible with the version number of 
   * the R that compiled this routine.
  */
  R_GE_checkVersionOrDie(R_GE_version);

  /* Declare local variabls for holding the components of the args SEXP */
  const char *fileName;
  const char *bg, *fg;
  double width, height;
  Rboolean standAlone, bareBones;
  const char *documentDeclaration, *packages, *footer;
  double baseSize;
  Rboolean console, sanitize;

  /* 
   * pGEDevDesc is a variable provided by the R Graphics Engine
   * that represents a graphics device to the rest of the R system.
   * It contains one important componant of type pDevDesc
   * which contains information specific to the implementation of
   * the MetaP Device. The creation and initialization of this component
   * is the main task of this routine.
  */
  pGEDevDesc tikzDev;


  /* Retrieve function arguments from input SEXP. */

  
  /*
   * Skip first argument. It holds the name of the R function
   * that called this C routine.
  */ 
  args = CDR(args);

  /* Recover file name. */
  fileName = translateChar(asChar(CAR(args)));
  /* Advance to next argument stored in the args SEXP. */
  args = CDR(args);

  /* Recover figure dimensions. */
  /* For now these are assumed to be in inches. */
  width = asReal(CAR(args)); args = CDR(args);
  height = asReal(CAR(args)); args = CDR(args);
  
  /* Recover initial background and foreground colors. */
  bg = CHAR(asChar(CAR(args))); args = CDR(args);
  fg = CHAR(asChar(CAR(args))); args = CDR(args);

  /* Recover the base fontsize */
  baseSize = asReal(CAR(args)); args = CDR(args);

  /* 
   * Set the standAlone parameter which specifies if the MetaP
   * pictures generated by this device should be wrapped in their
   * own LaTeX Document
  */
  standAlone = asLogical(CAR(args)); args = CDR(args);

  /* 
   * Set the bareBones parameter which specifies if MetaP code 
   * should be output directly without wrapping it a LaTeX document
   * or the tikzpicture environment.
  */
  bareBones = asLogical(CAR(args)); args = CDR(args);
  
  /* Grab the latex header and footers*/
  documentDeclaration = CHAR(asChar(CAR(args))); args = CDR(args);
  packages = CHAR(asChar(CAR(args))); args = CDR(args);
  footer = CHAR(asChar(CAR(args))); args = CDR(args);
  
  // Should the output be sent to the R console?
  console = asLogical(CAR(args)); args = CDR(args);
  /*
   * Should text strings passed to the plotting device be sent
   * to a sanitization function- i.e. to provide automatic
   * escaping of TeX special characters such as %,_,\, etc?
  */ 
  sanitize = asLogical(CAR(args)); args = CDR(args);

  /*
   * See the definition of tikz_engine in tikzDevice.h
   */
  int engine = asInteger(CAR(args));

  /* Ensure there is an empty slot avaliable for a new device. */
  R_CheckDeviceAvailable();

  BEGIN_SUSPEND_INTERRUPTS{

    /* 
     * The pDevDesc variable specifies the funtions and components 
     * that describe the specifics of this graphics device. After
     * setup, this information will be incorporated into the pGEDevDesc
     * variable tikzDev.
    */ 
    pDevDesc deviceInfo;

    /* 
     * Create the deviceInfo variable. If this operation fails, 
     * a 0 is returned in order to cause R to shut down due to the
     * possibility of corrupted memory.
    */
    if( !( deviceInfo = (pDevDesc) calloc(1, sizeof(DevDesc))) ) {
      return 0;
    }

    /*
     * Call setup routine to initialize deviceInfo and associate
     * R graphics function hooks with the appropriate C routines
     * in this file.
    */
    if( !MetaP_Setup( deviceInfo, fileName, width, height, bg, fg, baseSize,
        standAlone, bareBones, documentDeclaration, packages,
        footer, console, sanitize, engine ) ){
      /* 
       * If setup was unsuccessful, destroy the device and return
       * an error message.
      */
      free( deviceInfo );
      error("MetaP device setup was unsuccessful!");
    }

    /* Create tikzDev as a Graphics Engine device using deviceInfo. */
    tikzDev = GEcreateDevDesc( deviceInfo );

    /*
     * Register the device as an avaiable graphics device in the R
     * Session.  The user will now see a device labeled "tikz output"
     * when running functions such as dev.list().
    */ 
    GEaddDevice2( tikzDev, "metapost output" );

  } END_SUSPEND_INTERRUPTS;


  return R_NilValue;

}


/*
 * This function is responsible for initializing device parameters
 * contained in the variable deviceInfo. It returns a true or false
 * value depending on the success of initialization operations. The
 * static keyword means this function can only be seen by other functions
 * in this file. A better choice for the keyword might have been something
 * like "private"... 
*/

static Rboolean MetaP_Setup(
  pDevDesc deviceInfo,
  const char *fileName,
  double width, double height,
  const char *bg, const char *fg, double baseSize,
  Rboolean standAlone, Rboolean bareBones,
  const char *documentDeclaration,
  const char *packages, const char *footer, 
  Rboolean console, Rboolean sanitize, int engine ){

  /* 
   * Create tikzInfo, this variable contains information which is
   * unique to the implementation of the MetaP Device. The deviceInfo
   * variable contains a slot into which tikzInfo can be placed so that
   * this information persists and is retrievable during the lifespan
   * of this device.
   *
   * More information on the components of the deviceInfo structure,
   * which is a pointer to a DevDesc variable, can be found under
   * struct _DevDesc in the R header file GraphicsDevice.h
   *
   * tikzInfo is a structure which is defined in the file tikzDevice.h
  */
  tikzDevDesc *tikzInfo;
  
  pGEcontext plotParams;

  /*
   * pGEcontext is actually a *pointer* to a structure of type
   * R_GE_gcontext. If we don't allocate it, it will be passed
   * into the initialization routine without actually pointing
   * to anything. This causes nasty crashes- for some reason
   * only on Windows and Linux...
  */  
  if( !( plotParams = (pGEcontext) malloc(sizeof(pGEcontext)) ) ){
    return FALSE;
  }

  /* 
   * Initialize tikzInfo, return false if this fails. A false return
   * value will cause the whole device initialization routine to fail.
  */
  if( !( tikzInfo = (tikzDevDesc *) malloc(sizeof(tikzDevDesc)) ) ){
    return FALSE;
  }

  /* Copy MetaP-specific information to the tikzInfo variable. */
  tikzInfo->outFileName = (char*) calloc(strlen(fileName) + 1, sizeof(char));
  strcpy(tikzInfo->outFileName, fileName);
  tikzInfo->engine = metapost; // Also a hack.
  tikzInfo->rasterFileCount = 1;
  tikzInfo->firstPage = TRUE;
  tikzInfo->debug = DEBUG;
  tikzInfo->standAlone = standAlone;
  tikzInfo->bareBones = bareBones;
  tikzInfo->firstClip = TRUE;
  tikzInfo->oldFillColor = 0;
  tikzInfo->fill_color = NULL;
  tikzInfo->oldDrawColor = 0;
  tikzInfo->draw_color = NULL;
  tikzInfo->oldLineType = 0;
  tikzInfo->plotParams = plotParams;
  tikzInfo->stringWidthCalls = 0;
  tikzInfo->documentDeclaration = documentDeclaration;
  tikzInfo->packages = packages;
  tikzInfo->footer = footer;
  tikzInfo->polyLine = FALSE;
  tikzInfo->console = console;
  tikzInfo->sanitize = sanitize;

  /* A SEXP pointer to an object that will hold a list of defined colors */
  tikzInfo->colors = R_NilValue;


  /* Incorporate tikzInfo into deviceInfo. */
  deviceInfo->deviceSpecific = (void *) tikzInfo;

  /* 
   * These next statements define the capabilities of the device.
   * These capabilities include:
   *  -Device/user interaction
   *  -Gamma correction
   *  -Clipping abilities
   *  -UTF8 support
   *  -Text justification/alignment abilities
  */

  /* 
   * Define the gamma factor- used to adjust the luminosity of an image. 
   * Set to 1 since there is no gamma correction in the MetaP device. Also,
   * canChangeGamma is set to FALSE to disallow user adjustment of this
   * default.
  */
  deviceInfo->startgamma = 1;
  deviceInfo->canChangeGamma = FALSE;

  /*
   * canHAdj is an integer specifying the level of horizontal adjustment
   * or justification provided by this device. Currently set to 1 as this
   * is implemented by having the device insert /raggedleft, /raggedright
   * and /centering directives.
   *
   * Level 2 represents support for continuous variation between left aligned 
   * and right aligned- this is certainly possible in TeX but would take some
   * thought to implement.
  */
  deviceInfo->canHAdj = 1;

  /*
   * useRotatedTextInContour specifies if the text function along with
   * rotation parameters should be used over Hershey fonts when printing
   * contour plot labels. As one of the primary goals of this device
   * is to unify font choices, this value is set to true.
  */
  deviceInfo->useRotatedTextInContour = TRUE; 

  /*
   * canClip specifies whether the device implements routines for trimming
   * plotting output such that it falls within a rectangular clipping area.
  */
  deviceInfo->canClip = TRUE;

  /*
   * These next parameters speficy if the device reacts to keyboard and 
   * mouse events. Since this device outputs to a file, not a screen window, 
   * these actions are disabled.
  */
  deviceInfo->canGenMouseDown = FALSE;
  deviceInfo->canGenMouseMove = FALSE;
  deviceInfo->canGenMouseUp = FALSE;
  deviceInfo->canGenKeybd = FALSE;

  /* 
   * This parameter specifies whether the device is set up to handle UTF8
   * characters. This makes a difference in the complexity of the text
   * handling functions that must be built into the device. If set to true
   * both hook functions textUTF8 and strWidthUTF8 must be implemented.
   * Compared to ASCII, which only has 128 character values, UTF8 has
   * thousands.
   *
   * Version 0.6.0 of tikzDevice gained the ability to calculate metrics for
   * UTF8 encoded strings and characters. Those calculations are not done here
   * in the C code but implemented through the magical callback to R. On the R
   * level, we determine automatically is a string contains multibyte UTF8
   * characters and then use XeLaTeX.  Bottom line is, even though hasTextUTF8
   * is FALSE we can still print UTF8 characters and we dont need a separate
   * text handling function for UTF8 characters (thank god).
   * 
   * wantSymbolUTF8 indicates if mathematical symbols should be sent to
   * the device as UTF8 characters.  These can be handled in the same way as
   * normal UTF8 text and so wantSymbolUTF8 is TRUE.
  */
  deviceInfo->hasTextUTF8 = FALSE;
  switch (tikzInfo->engine) {
    case pdftex:
      deviceInfo->wantSymbolUTF8 = FALSE;
      break;
    case xetex:
    case metapost:
      deviceInfo->wantSymbolUTF8 = TRUE;
      break;
  }

  /*
   * Initialize device parameters. These concern properties such as the 
   * plotting canvas size, the initial foreground and background colors and 
   * the initial clipping area. Other parameters related to fonts and text 
   * output are also included.
  */

  /*
   * Set canvas size. The bottom left corner is considered the origin and 
   * assigned the value of 0pt, 0pt. The upper right corner is assigned by 
   * converting the specified height and width of the device to points.
  */
  deviceInfo->bottom = 0;
  deviceInfo->left = 0;
  deviceInfo->top = dim2dev( height );
  deviceInfo->right = dim2dev( width );

  /* Set default character size in pixels. */
  deviceInfo->cra[0] = 9;
  deviceInfo->cra[1] = 12;

  /* Set initial font. */
  deviceInfo->startfont = 1;

  /* Set base font size. */
  deviceInfo->startps = baseSize;

  /* 
   * Apparently these are supposed to center text strings over the points at
   * which they are plotted. MetaP does this automagically.
   *
   * We hope.
   *
  */
  deviceInfo->xCharOffset = 0;
  deviceInfo->yCharOffset = 0;
  deviceInfo->yLineBias = 0;

  /* Specify the number of inches per pixel in the x and y directions. */
  deviceInfo->ipr[0] = 1/dim2dev(1);
  deviceInfo->ipr[1] = 1/dim2dev(1);

  /* Set initial foreground and background colors. */
  deviceInfo->startfill = R_GE_str2col( bg );
  deviceInfo->startcol = R_GE_str2col( fg );

  /* Set initial line type. */
  deviceInfo->startlty = 0;


  /* 
   * Connect R graphic function hooks to MetaP Routines implemented in this
   * file. Each routine performs a specific function such as adding text, 
   * drawing a line or reporting/adjusting the status of the device.
  */

  /* Utility routines. */
  deviceInfo->close = MetaP_Close;
  deviceInfo->newPage = MetaP_NewPage;
  deviceInfo->clip = MetaP_Clip;
  deviceInfo->size = MetaP_Size;

  /* Text routines. */
  deviceInfo->metricInfo = MetaP_MetricInfo;
  deviceInfo->strWidth = MetaP_StrWidth;
  deviceInfo->text = MetaP_Text;

  /* Drawing routines. */
  deviceInfo->line = MetaP_Line;
  deviceInfo->circle = MetaP_Circle;
  deviceInfo->rect = MetaP_Rectangle;
  deviceInfo->polyline = MetaP_Polyline;
  deviceInfo->polygon = MetaP_Polygon;
  /*
   * The following function was added in R 2.12.0, Graphics Engine
   * version 8. See tikzDevice.h for more details.
  */
#if R_GE_version >= 8
  deviceInfo->path = MetaP_Path;
#endif

  /* 
   * Raster Routines.  Currently implemented as stub functions to
   * avoid nasty crashes. 
  */
  deviceInfo->raster = MetaP_Raster;
  deviceInfo->cap = MetaP_Cap;

  /* Dummy routines. These are mainly used by GUI graphics devices. */
  deviceInfo->activate = MetaP_Activate;
  deviceInfo->deactivate = MetaP_Deactivate;
  deviceInfo->locator = MetaP_Locator;
  deviceInfo->mode = MetaP_Mode;

  /* Call MetaP_Open to create and initialize the output file. */
  if( !MetaP_Open( deviceInfo ) ){
    return FALSE;
  }

  return TRUE;

}

/*
 * This function is responsible for converting lengths given in page
 * dimensions (ie. inches, cm, etc.) to device dimensions (currenty
 * points- 1/72.27 of an inch). However, due to the flexability of TeX
 * and MetaP, any combination of device and user dimensions could
 * theoretically be supported.
*/
static double dim2dev( double length ){
  return length * 72.0;
}


/*
 * This function is responsible for writing header information
 * to the output file. Currently this header information includes:
 *
 *   - The current version number of MetaP device.
 *   - The date on which the graphic was created.
 *
*/
static void Print_MetaP_Header( tikzDevDesc *tikzInfo ){

  /* Call back to R to retrieve current date and version num*/

  /*
   * Recover package namespace as the date formatting function
   * is not exported
  */
  SEXP MetaP_namespace;
  PROTECT( 
    MetaP_namespace = eval(lang2( install("getNamespace"),
      ScalarString(mkChar("tikzDevice")) ), R_GlobalEnv )
  );


  SEXP currentDate;
  PROTECT( 
    currentDate = eval(lang1( install("getDateStampForTikz") ), 
      MetaP_namespace )
  );

  SEXP currentVersion;
  PROTECT( 
    currentVersion = eval(lang1( install("getTikzDeviceVersion") ), 
      MetaP_namespace )
  );

  printOutput( tikzInfo, "%% Created by tikzDevice version %s on %s\n",
    CHAR(STRING_ELT(currentVersion,0)), CHAR(STRING_ELT(currentDate,0)) );

	//Specifically for TeXShop, force it to open the file with UTF-8 encoding
	printOutput(tikzInfo, "%% !TEX encoding = UTF-8 Unicode\n");

  UNPROTECT(3);

}

static Rboolean MetaP_Open( pDevDesc deviceInfo ){

  /* 
   * Shortcut pointers to variables of interest. 
   * It seems like there HAS to be a more elegent way of accesing
   * these...
  */
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;
  
  if(tikzInfo->outFileName[0] == '\0'){
    //If empty file name output to console
    tikzInfo->console = TRUE; 
  }else{  
    if( !( tikzInfo->outputFile = fopen(R_ExpandFileName(tikzInfo->outFileName), "w") ) )
      return FALSE;
  }

  /* Print header comment */
  Print_MetaP_Header( tikzInfo );

  printOutput(tikzInfo, "\\starttext\n\n");
  printOutput(tikzInfo, "\\switchtobodyfont[10pt]\n\n");

  /*Show only for debugging*/
  if(tikzInfo->debug == TRUE)
    printOutput(tikzInfo,"%% Beginning MetaPost graphic\n");

  printOutput(tikzInfo, "\\startMPpage\n");

  return TRUE;

}

static void MetaP_Close( pDevDesc deviceInfo){

  /* Shortcut pointers to variables of interest. */
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  double cx0, cx1, cy0, cy1;
  cx0 = deviceInfo->clipLeft;
  cx1 = deviceInfo->clipRight;
  cy0 = deviceInfo->clipBottom;
  cy1 = deviceInfo->clipTop;
  printOutput(tikzInfo, "\tclip currentpicture to unitsquare xscaled %6.2f yscaled %6.2f shifted (%6.2f,%6.2f);\n",
      cx1 - cx0, cy1 - cy0, cx0, cy0);
  printOutput(tikzInfo, "\tpopcurrentpicture;\n");

  printOutput(tikzInfo, "\\stopMPpage\n");
  
  printOutput(tikzInfo,"\n\\stoptext\n");
  
  if(tikzInfo->debug == TRUE) 
    printOutput(tikzInfo,
      "%% Calculated string width %d times\n",
      tikzInfo->stringWidthCalls);

  if(tikzInfo->console == FALSE)
    fclose(tikzInfo->outputFile);

  SEXP TikZ_namespace;
  PROTECT(
    TikZ_namespace = eval(lang2( install("getNamespace"),
      ScalarString(mkChar("tikzDevice")) ), R_GlobalEnv )
  );

  SEXP RCallBack;
  PROTECT( RCallBack = allocVector(LANGSXP,3) );


  SEXP mangle_fun;
  PROTECT(mangle_fun = findFun(install("evil_color_mangler"), TikZ_namespace));
  SETCAR(RCallBack, mangle_fun);

  SETCADR(RCallBack, mkString(tikzInfo->outFileName));
  SET_TAG(CDR(RCallBack), install("output_file"));

  SETCADDR(RCallBack, tikzInfo->colors);
  SET_TAG(CDDR(RCallBack), install("device_colors"));

  eval(RCallBack, TikZ_namespace);

  UNPROTECT(3);

  /* Deallocate pointers */
  free(tikzInfo->outFileName);
  free(tikzInfo->fill_color);
  free(tikzInfo->draw_color);
  free(tikzInfo);

}

static void MetaP_NewPage( const pGEcontext plotParams, pDevDesc deviceInfo ){

  /* Shortcut pointers to variables of interest. */
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  if ( tikzInfo->firstPage ){
    tikzInfo->firstPage = FALSE;
  }else{

    double cx0, cx1, cy0, cy1;
    cx0 = deviceInfo->clipLeft;
    cx1 = deviceInfo->clipRight;
    cy0 = deviceInfo->clipBottom;
    cy1 = deviceInfo->clipTop;
    printOutput(tikzInfo, "\tclip currentpicture to unitsquare xscaled %6.2f yscaled %6.2f shifted (%6.2f,%6.2f);\n",
        cx1 - cx0, cy1 - cy0, cx0, cy0);
    printOutput(tikzInfo, "\tpopcurrentpicture;\n");
    printOutput(tikzInfo, "\\stopMPpage\n");
    
    /*Next clipping region will be the first on the page*/
    tikzInfo->firstClip = TRUE;

    /*Show only for debugging*/
    if(tikzInfo->debug == TRUE) 
      printOutput(tikzInfo,
        "%% Beginning new MetaPost graphic\n");

    /* Start a new MetaP envioronment. */
    printOutput(tikzInfo, 
      "\n\\startMPpage\n");

  } /* End if first page */


  /* Define reusable path variable */
  printOutput(tikzInfo, "\tpath p;\n");
  /*
   * Define default pen and other graphics parameters. 0.4pt matches the
   * default used by TikZ
   */
  printOutput(tikzInfo, "\tpickup pencircle scaled 0.4pt;");
  printOutput(tikzInfo, "\tlinecap := butt;");
  printOutput(tikzInfo, "\tlinejoin := mitered;\n\n");

  /* Fill canvas background */
  printOutput(tikzInfo, "\tp := unitsquare xscaled %6.2f yscaled %6.2f;\n",
    deviceInfo->right,deviceInfo->top);
  MetaP_DrawStyle(plotParams, tikzInfo, TRUE);
  /*
   * This is needed in case the fill is transparent and the command above does
   * not do anything.
   */
  printOutput(tikzInfo, "\tsetbounds currentpicture to p;\n");

}

static void MetaP_Clip( double x0, double x1, 
    double y0, double y1, pDevDesc deviceInfo ){

  /* Shortcut pointers to variables of interest. */
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  /*
   * Difference between MetaPost and TikZ: The clipping operation is done at
   * the end of the scope rather than the beginning.
   */
  double cx0, cx1, cy0, cy1;
  cx0 = deviceInfo->clipLeft;
  cx1 = deviceInfo->clipRight;
  cy0 = deviceInfo->clipBottom;
  cy1 = deviceInfo->clipTop;

  if(tikzInfo->firstClip == FALSE){
    printOutput(tikzInfo, "\tclip currentpicture to unitsquare xscaled %6.2f yscaled %6.2f shifted (%6.2f,%6.2f);\n",
        cx1 - cx0, cy1 - cy0, cx0, cy0);
    printOutput(tikzInfo, "\tpopcurrentpicture;\n");
  }else{
    tikzInfo->firstClip = FALSE;
  }

  deviceInfo->clipBottom = y0;
  deviceInfo->clipLeft = x0;
  deviceInfo->clipTop = y1;
  deviceInfo->clipRight = x1;
  

  printOutput(tikzInfo, "\tpushcurrentpicture;\n");
  /*
  printOutput(tikzInfo,
    "\\path[clip] (%6.2f,%6.2f) rectangle (%6.2f,%6.2f);\n",
    x0,y0,x1,y1);
  */

  /*
   *     *** UGLY HACK ***
   * 
   * So, the device was building fine on Linux and Windows,
   * but when it came time to comple the output- pdflatex
   * barfed on both systems, complaining about fillColor or
   * drawColor not being defined. I'm pretty sure this is
   * because those color values are not preserved accross
   * scopes.
   *
   * I'm too tired to figure out the StyleDef code in detail
   * right now, so i'm tweaking the stored values here in
   * the hopes that it will force a reprint of style after
   * we begin a new scope.
   *
   * Seems to work.
  */
  tikzInfo->oldFillColor = -999;
  tikzInfo->oldDrawColor = -999;
  tikzInfo->oldLineType = -999;

}

static void MetaP_Size( double *left, double *right,
    double *bottom, double *top, pDevDesc deviceInfo){
  
  /* Return canvas size. */
  *bottom = deviceInfo->bottom;
  *left = deviceInfo->left;
  *top = deviceInfo->top;
  *right = deviceInfo->right;

}

/*
 * This function calculates an appropriate scaling factor for text by
 * first calculating the ratio of the requested font size to the LaTeX
 * base font size. The ratio is then further scaled by the value of
 * the character expansion factor cex.
*/
double
MetaP_ScaleFont( const pGEcontext plotParams, pDevDesc deviceInfo ){

  // These parameters all affect the font size.
  double baseSize = deviceInfo->startps;
  double fontSize = plotParams->ps;
  double cex = plotParams->cex;

  double fontScale = ( fontSize / baseSize ) * cex;

  return( fontScale );

}

/*
 * This function is supposed to calculate character metrics (such as raised 
 * letters, stretched letters, ect). Currently the MetaP device does not 
 * perform such functions, so this function returns the default metrics
 * the Quartz device uses when it can't think of anything else.
 * 
 * The fact that this function is not implemented is the most likely cause
 * for the *vertical* alignment of text strings being off. This shortcoming
 * is most obvious when plot legends are created.
 *
*/ 
static void MetaP_MetricInfo(int c, const pGEcontext plotParams,
    double *ascent, double *descent, double *width, pDevDesc deviceInfo ){


  /* Shortcut pointers to variables of interest. */
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  if (tikzInfo->engine == pdftex) {
    /*
     * PdfTeX can only deal with ASCII characters, check the character code c
     * to see if it falls outside the range of printable characters which are:
     * 32-126
     */
    if( c < 32 || c > 126 ){
      /* Non-printable character. Set metrics to zero and return. */
      *ascent = 0.0;
      *descent = 0.0;
      *width = 0.0;
      return;
    }
  }

  // Calculate font scaling factor.
  double fontScale = MetaP_ScaleFont( plotParams, deviceInfo );

  // Prepare to call back to R in order to retrieve character metrics.
  SEXP MetaP_namespace;
  PROTECT(
    MetaP_namespace = eval(lang2( install("getNamespace"),
      ScalarString(mkChar("tikzDevice")) ), R_GlobalEnv )
  );
  
  // Call out to R to retrieve the latexParseCharForMetrics function.
  // Note: this code will eventually call a different function that provides
  // caching of the results. Right now we're directly calling the function
  // that activates LaTeX.
  SEXP metricFun = findFun( install("getLatexCharMetrics"), MetaP_namespace );

  SEXP RCallBack;
  PROTECT( RCallBack = allocVector(LANGSXP,5) );

  // Place the function into the first slot of the SEXP.
  SETCAR( RCallBack, metricFun );

  // Place the character code into the second slot of the SEXP.
  SETCADR( RCallBack, ScalarInteger( c ) );
  SET_TAG( CDR( RCallBack ), install("charCode") );

  // Pass graphics parameters cex and fontface.
  SETCADDR( RCallBack,  ScalarReal( fontScale ) );
  SET_TAG( CDDR( RCallBack ), install("cex") );
  SETCADDDR( RCallBack,  ScalarInteger( plotParams->fontface ) );
  SET_TAG( CDR(CDDR( RCallBack )), install("face") );

  /*
   * Set the TeX engine based on tikzInfo
   */
  switch (tikzInfo->engine) {
    case pdftex:
      SETCAD4R(RCallBack, mkString("pdftex"));
      break;
    case xetex:
      SETCAD4R(RCallBack, mkString("xetex"));
      break;
    case metapost:
    SETCAD4R(RCallBack, mkString("metapost"));
    break;
  }
  SET_TAG(CDDR(CDDR(RCallBack)), install("engine"));

  SEXP RMetrics;
  PROTECT( RMetrics = eval( RCallBack, MetaP_namespace ) );

  // Recover the metrics.
  *ascent = REAL(RMetrics)[0];
  *descent = REAL(RMetrics)[1];
  *width = REAL(RMetrics)[2];

  if( tikzInfo->debug == TRUE )
  printOutput( tikzInfo, "%% Calculated character metrics. ascent: %f, descent: %f, width: %f\n",
    *ascent, *descent, *width);

  UNPROTECT(3);

  return;

}

/*
 * This function is supposed to calculate the plotted with, in device raster
 * units of an arbitrary string. This is perhaps the most difficult function
 * that a device needs to implement. Calculating the exact with of a string 
 * is especially tricky because this device is designed to print characters 
 * in whatever font is being used in the the TeX document. The end font that
 * the user decides to typeset their document in may also be unknown to the
 * device. The problem is further complicated by the fact that TeX strings 
 * can be used directly in annotations.  For example the string \textit{x} 
 * literaly has 10 characters but when it is actually typeset it only has
 * one. Given this difficulty the function currently writes the string
 * to a temporary file and calls LaTeX in order to obtain an authoratative
 * measure of the string width.
 *
 * There is a rediculous amount of overhead involved with this process and
 * the number of calls required to obtion widths for common things such as
 * all the number s on a plot axes can easily add up to several seconds.
 *
 * However, if we do not perform string width calculation R is unable to
 * properly align text in the plots R. This is something that LaTeX and
 * MetaP should actually be taking care of by themselves but the current
 * graphics system does not allow for this.
 *
 * Given that we need text strings to be aligned for good output, we are
 * stuck using this inefficient hybrid system untill we think of something
 * better.
 *
*/
static double MetaP_StrWidth( const char *str,
    const pGEcontext plotParams, pDevDesc deviceInfo ){
      
  /* Shortcut pointers to variables of interest. */
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  // Calculate font scaling factor.
  double fontScale = MetaP_ScaleFont( plotParams, deviceInfo );

  /*
   * New string width calculation method: call back to R
   * and run the R function getLatexStrWidth.
   *
   * This used to be implemented as a C function, but
   * the nuts and bolts were re-implemented back
   * on the R side of this package. There seems to
   * have been no major performance penalty associated
   * with doing this.
   *
   * Why was it done?
   *
   * - Windows and Linux did not suppress the output
   *   of the C system call to LaTeX which resulted 
   *   in spam and lag. In the case of Windows, a
   *   whole mess of CMD windows were spawned which
   *   eventually crashed the system.
   *
   * - Using R's system() call we gain a level of
   *   abstraction that works accross all platforms.
   *   We can also use functions like tempdir() to
   *   do the dirty work somewhere where the user
   *   won't have to clean it up.
   *
   * - If a LaTeX parser ever gets implemented, it
   *   will probably be easiest to implement it in
   *   R. If a LaTeX parser ever gets stolen from
   *   something like python's matplotlib, R will
   *   probably provide the interface. Therefore
   *   a callback to R may be necessary anyway.
   *
   * - Having C code called by R call R code is 
   *   fucking wicked.
   *
  */

  /*
   * Find the namespace of the MetaP package.
   */
  SEXP MetaP_namespace;
  PROTECT(
    MetaP_namespace = eval(lang2( install("getNamespace"),
      ScalarString(mkChar("tikzDevice")) ), R_GlobalEnv )
  );

  // Call out to R to retrieve the getLatexStrWidth function.
  SEXP widthFun = findFun(install("getLatexStrWidth"), MetaP_namespace);

  /*
   * Create a SEXP that will be the R function call. The SEXP will have five
   * components- the R function being called, the string being passed, the
   * current value of the graphics parameters cex and fontface and the TeX
   * engine to be used. Therefore it is allocated as a  LANGSXP vector of
   * length 5. This is done inside a PROTECT() function to keep the R garbage
   * collector from saying "Hmmm... what's this? Looks like noone is using it
   * so I guess I will nuke it."
  */
  SEXP RCallBack;
  PROTECT( RCallBack = allocVector(LANGSXP, 5) );

  // Place the function into the first slot of the SEXP.
  SETCAR( RCallBack, widthFun );

  //If using the sanitize option call back to R for the sanitized string
  char *cleanString = NULL;
  if(tikzInfo->sanitize == TRUE){
    cleanString = Sanitize( str );
    // Place the sanitized string into the second slot of the SEXP.
    SETCADR( RCallBack, mkString( cleanString ) );
    
  }else{
    
    // Place the string into the second slot of the SEXP.
    SETCADR( RCallBack, mkString( str ) );
    
  }
  // Tag the string with a name, this name coressponds to the
  // dummy argument of the R function getLatexStringWidth.
  SET_TAG( CDR( RCallBack ), install("texString") );

  // Pass graphics parameters cex and fontface.
  SETCADDR( RCallBack,  ScalarReal( fontScale ) );
  SET_TAG( CDDR( RCallBack ), install("cex") );
  SETCADDDR( RCallBack,  ScalarInteger( plotParams->fontface ) );
  SET_TAG( CDR(CDDR( RCallBack )), install("face") );

  /*
   * Set the TeX engine based on tikzInfo
   */
  switch (tikzInfo->engine) {
    case pdftex:
      SETCAD4R(RCallBack, mkString("pdftex"));
      break;
    case xetex:
      SETCAD4R(RCallBack, mkString("xetex"));
      break;
    case metapost:
      SETCAD4R(RCallBack, mkString("metapost"));
      break;
  }
  SET_TAG(CDDR(CDDR(RCallBack)), install("engine"));

  /*
   * Call the R function, capture the result.
   * PROTECT may not be necessary here, but I'm doing
   * it just in case the SEXP holds a pointer to an
   * R function return value that the garbage collector
   * decides to nuke.
  */
  SEXP RStrWidth;
  PROTECT( RStrWidth = eval( RCallBack, MetaP_namespace ) );

  /*
   * Why REAL()[0] instead of asReal(CAR())? I have no fucking
   * clue...
   *
   * After browsing Rinternals.h, the location where SEXPs and
   * their access functions are defined, I have an explanation
   * that seems plausible.
   *
   * Since getLatexStrWidth returns a single variable of a single
   * type, it is returned as a vector SEXP. The value can be
   * extracted to a C variable by coercing the SEXP to real and
   * then accessing the first element of the resulting array.
   *
   * When a R function returns, or passes in the case of the 
   * .External call that leads into all of this code, a collection
   * of *different* objects they are passed as a list instead of
   * a vector. Therefore CAR is needed to access the list followed
   * by coercion using asReal().
   *
   * Seems like this explains what is going on here, although it
   * is just a wild guess on my part. Maybe I should post to
   * r-devel and ask for clarification...
   *
  */
  double width = REAL(RStrWidth)[0];

  /*
   * Since we called PROTECT thrice, we must call UNPROTECT
   * and pass the number 3.
   */
  UNPROTECT(3);
  if(tikzInfo->sanitize == TRUE){ free(cleanString); }
  
  /*Show only for debugging*/
  if(tikzInfo->debug == TRUE) 
    printOutput(tikzInfo,
      "%% Calculated string width of %s as %f\n",str,width);
  
  /*
   * Increment the number of times this function has been called
   * Used for debugging purposes.
   *
  */
  tikzInfo->stringWidthCalls++;

  return(width);
    
}

/*
 * This function should plot a string of text at coordinates x and y with
 * a rotation value specified by rot and horizontal alignment specified by
 * hadj. Additional parameters such as color, font type, font style, line
 * height and font size are specified in the pGEcontext variable plotParams.
 *
 * The rotation value is given in degrees.
*/
static void MetaP_Text( double x, double y, const char *str,
    double rot, double hadj, const pGEcontext plotParams,
    pDevDesc deviceInfo){

  /* Shortcut pointers to variables of interest. */
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  double tol = 0.01;

  // Append font face commands depending on which font R is using.
  char *tikzString = (char *) calloc( strlen(str) + 6, sizeof(char) );

  switch( plotParams->fontface ){

    case 2:
      // R is requesting bold font.
      strcat( tikzString, "\\bf " );
      break;

    case 3:
      // R is requesting italic font.
      strcat( tikzString, "\\it " );
      break;

    case 4:
      // R is requesting bold italic font.
      strcat( tikzString, "\\bs " );
      break;

  } // End font face switch.

  // Form final output string.
  strcat( tikzString, str );

  // Calculate font scaling factor.
  double fontScale = MetaP_ScaleFont( plotParams, deviceInfo );


  /* Start a node for the text, open an options bracket. */
  printOutput(tikzInfo,"label.");

  //Justify the text
  if(fabs(hadj - 0.0) < tol){
    //Left Justified
    printOutput(tikzInfo, "urt(btex ");
  }
  if(fabs(hadj - 0.5) < tol){
    //Center Justified
    printOutput(tikzInfo, "top(btex ");
  }
  if(fabs(hadj - 1) < tol){
    //Right Justified
    printOutput(tikzInfo, "ulft(btex ");
  }

  char *cleanString = NULL;
  if(tikzInfo->sanitize == TRUE){
    //If using the sanitize option call back to R for the sanitized string
    cleanString = Sanitize( tikzString );
  	if(tikzInfo->debug == TRUE)
    	printOutput(tikzInfo,"\n%% Sanatized %s to %s\n",tikzString,cleanString);
    printOutput(tikzInfo, "%s etex", cleanString);
  }else{
    printOutput(tikzInfo, "%s etex", tikzString);
  }

  printOutput(tikzInfo, " scaled %6.2f, (%6.2f,%6.2f))", fontScale, x, y);

  /* Rotate the text if desired. */
  if ( rot != 0 ) {
    printOutput(tikzInfo, " rotatedaround ((%6.2f, %6.2f), %6.2f)", x, y, rot);
  }

  /* Finally, clean up */
  printOutput(tikzInfo, ";\n");

  /*
   * Since we no longer need tikzString,
   * we should free the memory that it is being stored in.
  */
  free( tikzString );
  if(tikzInfo->sanitize == TRUE){ free( cleanString ); }

  /*
   * Add a small red marker to indicate the
   * point the text string is being aligned to.
   */
  if( DEBUG == TRUE )
    printOutput(tikzInfo,
      "\ndraw fullcircle scaled 0.5pt shifted (%6.2f,%6.2f) withcolor red;\n",
      x, y);

}


static void MetaP_Line( double x1, double y1,
    double x2, double y2, const pGEcontext plotParams, pDevDesc deviceInfo){

  /* Shortcut pointers to variables of interest. */
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  double x[] = {x1, x2};
  double y[] = {y1, y2};

  /*Show only for debugging*/
  if(tikzInfo->debug == TRUE)
    printOutput(tikzInfo,
      "%% Drawing line from x1 = %10.4f, y1 = %10.4f to x2 = %10.4f, y2 = %10.4f\n",
      x1,y1,x2,y2);

  MetaP_DrawLines(2, x, y, plotParams, deviceInfo, FALSE);
  /* Draw the path */
  MetaP_DrawStyle(plotParams, tikzInfo, FALSE);

}

static void MetaP_Circle( double x, double y, double r,
    const pGEcontext plotParams, pDevDesc deviceInfo){

  /* Shortcut pointers to variables of interest. */
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  /*Show only for debugging*/
  if(tikzInfo->debug == TRUE) 
    printOutput(tikzInfo,
      "%% Drawing Circle at x = %f, y = %f, r = %f\n",
      x,y,r);

  /*
   * Draw circle. Note for MetaPost, the circle has to be scaled before its
   * origin is shifted or the results will be funky. Also, the scale applies to
   * the whole circle, so it is a *diameter*. This means we need to multiply
   * radius by 2.
   *
   * MetaPost also has a unitcircle, but I believe this is anchored at the
   * lower left corner rather than the center.
   */
  printOutput(tikzInfo, "\tp := fullcircle scaled %6.2f shifted (%6.2f,%6.2f);\n",
    r * 2.0,x,y);
  /* Fill the path */
  MetaP_DrawStyle(plotParams, tikzInfo, TRUE);
  /* Draw the path */
  MetaP_DrawStyle(plotParams, tikzInfo, FALSE);

}

static void MetaP_Rectangle( double x0, double y0,
    double x1, double y1, const pGEcontext plotParams, pDevDesc deviceInfo){

  /* Shortcut pointers to variables of interest. */
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  /*Show only for debugging*/
  if(tikzInfo->debug == TRUE)
    printOutput(tikzInfo,
      "%% Drawing Rectangle from x0 = %f, y0 = %f to x1 = %f, y1 = %f\n",
      x0,y0,x1,y1);

  printOutput(tikzInfo,
    "\tp := unitsquare xscaled %6.2f yscaled %6.2f shifted (%6.2f,%6.2f);\n",
    x1 - x0, y1 - y0, x0, y0);
  /* Fill the path */
  MetaP_DrawStyle(plotParams, tikzInfo, TRUE);
  /* Draw the path */
  MetaP_DrawStyle(plotParams, tikzInfo, FALSE);

}

static void MetaP_Polyline( int n, double *x, double *y,
    pGEcontext plotParams, pDevDesc deviceInfo ){

  /* Shortcut pointers to variables of interest. */
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  /*Show only for debugging*/
  if(tikzInfo->debug == TRUE)
    printOutput(tikzInfo,
      "%% Starting Polyline\n");

  MetaP_DrawLines(n, x, y, plotParams, deviceInfo, FALSE);
  /* Draw the path */
  MetaP_DrawStyle(plotParams, tikzInfo, FALSE);

  /*Show only for debugging*/
  if(tikzInfo->debug == TRUE)
    printOutput(tikzInfo,
      "%% End Polyline\n");

}

static void MetaP_Polygon( int n, double *x, double *y,
    pGEcontext plotParams, pDevDesc deviceInfo ){

  /* Shortcut pointers to variables of interest. */
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  /*Show only for debugging*/
  if(tikzInfo->debug == TRUE)
    printOutput(tikzInfo,
      "%% Starting Polygon\n");

  MetaP_DrawLines(n, x, y, plotParams, deviceInfo, TRUE);
  /* Fill the path */
  MetaP_DrawStyle(plotParams, tikzInfo, TRUE);
  /* Draw the path */
  MetaP_DrawStyle(plotParams, tikzInfo, FALSE);

  /*Show only for debugging*/
  if(tikzInfo->debug == TRUE)
    printOutput(tikzInfo,
      "%% End Polyline\n");

}

static void MetaP_DrawLines(int n, double *x, double *y,
  pGEcontext plotParams, pDevDesc deviceInfo, Rboolean close_path) {

  /* Shortcut pointers to variables of interest. */
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  /* Start drawing*/
  printOutput(tikzInfo,"\tp := ((%6.2f,%6.2f)",
      x[0], y[0]);

  /* Print coordinates for the middle segments of the line. */
  int i;
  for ( i = 1; i < n; i++ ){

    printOutput(tikzInfo, " --\n\t(%6.2f,%6.2f)",
      x[i],y[i]);

  }

  if (close_path) {

    printOutput(tikzInfo, " --\n\tcycle);\n");

  } else {

    printOutput(tikzInfo, ");\n");

  }

}


#if R_GE_version >= 8
/* Currently a non-functional stub. */
static void
MetaP_Path( double *x, double *y,
  int npoly, int *nper,
  Rboolean winding,
  const pGEcontext plotParams, pDevDesc deviceInfo
){

  warning("The MetaPost device does not implement polypaths");
  return R_NilValue;

}
#endif


/*
 * This routine assumes that the main graphics routines have stored a path
 * definition in a MetaPost variable `p`. The routine then fills or draws `p`
 * based on the value of the `fill` parameter.
 */
static void MetaP_DrawStyle(pGEcontext plotParams, tikzDevDesc *tikzInfo, Rboolean fill){
  int color;
  char *color_name = NULL;

  /*
   * Calculate "style code". This examines the fill colors and draw colors and
   * decides if a fill or draw operation needs to happen. Taking this code into
   * account prevents "white lines" from showing up in the output.
   *
   * code is set as follows:
   *   code == 0, nothing to draw
   *   code == 1, outline only
   *   code == 2, fill only
   *   code == 3, outline and fill
   */
  int code = 3 - 2 * (R_TRANSPARENT(plotParams->fill)) - (R_TRANSPARENT(plotParams->col));

  if (fill && (code & 2)) {
    /* Filling is pretty easy, no need to define line styles, joins, etc. */
    printOutput(tikzInfo, "\tfill p ");

    color = plotParams->fill;
    if(color != tikzInfo->oldFillColor){
      tikzInfo->oldFillColor = color;
      if ( tikzInfo->fill_color ) free(tikzInfo->fill_color);
      tikzInfo->fill_color = MetaP_GetColorName(color);
    }

    color_name = tikzInfo->fill_color;

  } else if (!fill && (code & 1)) {

    /*
     * Start a graphics group so that variables like linecap, and mitre limit
     * can be adjusted.
     */
    printOutput(tikzInfo, "\tbegingroup;\n");
    switch (plotParams->lend) {
      case GE_ROUND_CAP:
        printOutput(tikzInfo, "\t\tinterim linecap := rounded;\n");
        break;
      case GE_BUTT_CAP:
        /*Default if nothing is specified*/
        break;
      case GE_SQUARE_CAP:
        printOutput(tikzInfo, "\t\tinterim linecap := squared;\n");
    }

    switch (plotParams->ljoin) {
      case GE_ROUND_JOIN:
        printOutput(tikzInfo, "\t\tinterim linejoin := rounded;\n");
        break;
      case GE_MITRE_JOIN:
        /*Default if nothing is specified*/
        if(plotParams->lmitre != 10)
          printOutput(tikzInfo, "\t\tinterim miterlimit := %4.2fpt;\n",plotParams->lmitre);
        break;
      case GE_BEVEL_JOIN:
        printOutput(tikzInfo, "\t\tinterim linejoin := beveled;\n");
    }


    printOutput(tikzInfo, "\t\tdraw p");

    color = plotParams->col;
    if(color != tikzInfo->oldDrawColor){
      tikzInfo->oldDrawColor = color;
      if ( tikzInfo->draw_color ) free(tikzInfo->draw_color);
      tikzInfo->draw_color = MetaP_GetColorName(color);
    }

    color_name = tikzInfo->draw_color;

    /* Additional actions for drawing paths such as line width and dashing */
    SetDashPattern(plotParams->lty, tikzInfo);
    if(plotParams->lwd != 1.0)
      printOutput(tikzInfo," withpen pencircle scaled %4.1fpt", 0.4*plotParams->lwd);

  } else {
    /* Assuming code was 0 */
    return;
  }

  if ( R_OPAQUE(color) ) {
    printOutput(tikzInfo, " withcolor \\MPcolor{%s};\n", color_name);
  } else {
    unsigned int alpha = R_ALPHA(color);
    /*
     * Apparantly PDF has 12 (!!) different transparency styles which are
     * supported by MetaPost. We use the garden variety here, but there are tons
     * of options like "screen" and "burn" that could be investigated.
     */
    printOutput(tikzInfo, " withcolor transparent(\"normal\", %4.2f, \\MPcolor{%s});\n",
      alpha / 255.0, color_name);
  }

  /* Finish graphics group for altered linejoins, etc */
  if ( !fill && (code & 1) ) printOutput(tikzInfo, "\tendgroup;\n");

}


static void SetDashPattern(int lty, tikzDevDesc *tikzInfo){
  char dashlist[8];
  int i, nlty;

  /* From ?par
   * Line types can either be specified by giving an index into a small
   * built-in table of line types (1 = solid, 2 = dashed, etc, see lty
   * above) or directly as the lengths of on/off stretches of line. This
   * is done with a string of an even number (up to eight) of characters,
   * namely non-zero (hexadecimal) digits which give the lengths in
   * consecutive positions in the string. For example, the string "33"
   * specifies three units on followed by three off and "3313" specifies
   * three units on followed by three off followed by one on and finally
   * three off. The ‘units’ here are (on most devices) proportional to lwd,
   * and with lwd = 1 are in pixels or points or 1/96 inch.

   * The five standard dash-dot line types (lty = 2:6) correspond to
   * c("44", "13", "1343", "73", "2262").
   *
   * (0=blank, 1=solid (default), 2=dashed,
   *  3=dotted, 4=dotdash, 5=longdash, 6=twodash)
  */

  /*Retrieve the line type pattern*/
  for(i = 0; i < 8 && lty & 15 ; i++) {
    dashlist[i] = lty & 15;
    lty = lty >> 4;
  }
  nlty = i; i = 0;

  if (nlty < 2) return;

  printOutput(tikzInfo, " dashed dashpattern(");

  /*Set the dash pattern*/
  while(i < nlty){
    if( (i % 2) == 0 ){
      printOutput(tikzInfo, "on %dpt ", dashlist[i]);
    }else{
      printOutput(tikzInfo, "off %dpt ", dashlist[i]);
    }
    i++;
  }

  printOutput(tikzInfo, ")");

}


/*
 * Returns the engine used by a given tikzDevice
 */
SEXP MetaP_GetEngine(SEXP device_num){
  int dev_index = asInteger(device_num);
  pDevDesc deviceInfo = GEgetDevice(dev_index - 1)->dev;
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  return(ScalarInteger(tikzInfo->engine));
}

/*
 * Returns information stored in the tikzDevDesc structure for a given device.
 */
SEXP MetaP_DeviceInfo(SEXP device_num){

  int dev_index = asInteger(device_num);
  pDevDesc deviceInfo = GEgetDevice(dev_index - 1)->dev;
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  SEXP info, names;
  PROTECT( info = allocVector(VECSXP, 2) );
  PROTECT( names = allocVector(STRSXP, 2) );

  SET_VECTOR_ELT(info, 0, mkString(tikzInfo->outFileName));
  SET_STRING_ELT(names, 0, mkChar("output_file"));

  SET_VECTOR_ELT(info, 1, tikzInfo->colors);
  SET_STRING_ELT(names, 1, mkChar("colors"));

  setAttrib(info, R_NamesSymbol, names);

  UNPROTECT(2);
  return(info);

}

SEXP MetaP_SetColors(SEXP color_list, SEXP device_num){

  int dev_index = asInteger(device_num);
  pDevDesc deviceInfo = GEgetDevice(dev_index - 1)->dev;
  tikzDevDesc *tikzInfo = (tikzDevDesc *) deviceInfo->deviceSpecific;

  if (tikzInfo->colors != R_NilValue) R_ReleaseObject(tikzInfo->colors);

  tikzInfo->colors = color_list;
  R_PreserveObject(tikzInfo->colors);

  return R_NilValue;

}


static char *MetaP_GetColorName(int rgb_value){

  SEXP TikZ_namespace;
  PROTECT(
    TikZ_namespace = eval(lang2( install("getNamespace"),
      ScalarString(mkChar("tikzDevice")) ), R_GlobalEnv )
  );

  SEXP RCallBack;
  PROTECT( RCallBack = allocVector(LANGSXP, 2) );
  SETCAR( RCallBack, install("get_or_set_color") );

  SEXP rgb_vec;
  PROTECT( rgb_vec = allocVector(INTSXP, 3) );
  INTEGER(rgb_vec)[0] = R_RED(rgb_value);
  INTEGER(rgb_vec)[1] = R_GREEN(rgb_value);
  INTEGER(rgb_vec)[2] = R_BLUE(rgb_value);

  SETCADR( RCallBack, rgb_vec );
  SET_TAG( CDR(RCallBack), install("rgb_value") );

  SEXP color_name_sexp;
  PROTECT( color_name_sexp = eval( RCallBack, TikZ_namespace ) );
  const char *name_string = CHAR(asChar(color_name_sexp));
  char *color_name = (char *) calloc(strlen(name_string) + 1, sizeof(char));
  strcpy(color_name, name_string);

  UNPROTECT(4);

  return( color_name );

}


void printOutput(tikzDevDesc *tikzInfo, const char *format, ...){
  
  va_list(ap);
  va_start(ap, format);
  
  if(tikzInfo->console == TRUE)
    Rvprintf(format, ap);
  else
    vfprintf(tikzInfo->outputFile, format, ap);
  
  va_end(ap);
  
}

static char *Sanitize(const char *str){

  
  //Splice in escaped charaters via a callback to R
  
  //Call out to R to retrieve the sanitizeTexString function.
  SEXP sanitizeFun = findFun( install("sanitizeTexString"), R_GlobalEnv );

  /*
   * Create a SEXP that will be the R function call. The SEXP will
   * have four components- the R function being calledand the string 
   * being passed. Therefore it is allocated as a  LANGSXP
   * vector of length 2. This is done inside a PROTECT() function
   * to keep the R garbage collector from saying "Hmmm... what's
   * this? Looks like noone is using it so I guess I will nuke it."
  */
  SEXP RCallBack;
  PROTECT( RCallBack = allocVector(LANGSXP,2) );

  // Place the function into the first slot of the SEXP.
  SETCAR( RCallBack, sanitizeFun );
  
  // Place the string into the second slot of the SEXP.
  SETCADR( RCallBack, mkString( str ) );
  // Tag the string with a name, this name coressponds to the
  // dummy argument of the R function sanitizeTexString.
  SET_TAG( CDR( RCallBack ), install("string") );

  /*
   * Call the R function, capture the result.
  */
  SEXP RSanitizedString;
  PROTECT( RSanitizedString = eval( RCallBack, R_GlobalEnv ) );

  const char *cleanString = CHAR(asChar(RSanitizedString));

  //if(DEBUG)
  //  printf("Clean String: %s\n",cleanString);

  /* 
   * cleanString is a pointer to data derived from an R object.  Once UNPROTECT
   * is called, this object may be eaten by the R garbage collector.  Therefore,
   * we need to copy the data we care about into a new string.
  */
  char *cleanStringCP = (char *) calloc( strlen(cleanString) + 1, sizeof(char) );
  
  strcat(cleanStringCP, cleanString);

  // Since we called PROTECT twice, we must call UNPROTECT
  // and pass the number 2.
  UNPROTECT(2);
  
  return cleanStringCP;
}

static Rboolean contains_multibyte_chars(const char *str){
  /*
   * Recover package namespace as the multibyte check function
   * is not exported
  */
  SEXP MetaP_namespace;
  PROTECT(
    MetaP_namespace = eval(lang2( install("getNamespace"),
      ScalarString(mkChar("tikzDevice")) ), R_GlobalEnv )
  );

  SEXP multibyte_check_fun = findFun(
      install("anyMultibyteUTF8Characters"), MetaP_namespace );

  SEXP RCallBack;
  PROTECT( RCallBack = allocVector(LANGSXP,2) );

  // Place the function into the first slot of the SEXP.
  SETCAR( RCallBack, multibyte_check_fun );

  // Place the string into the second slot of the SEXP.
  SETCADR( RCallBack, mkString( str ) );
  SET_TAG( CDR( RCallBack ), install("string") );

  /*
   * Call the R function, capture the result.
  */
  SEXP result;
  PROTECT( result = eval( RCallBack, MetaP_namespace ) );

  UNPROTECT(3);

  return(asLogical(result));
}


/*
 * Creates a raster image whose lower left corner is centered at the
 * coordinates given by x and y.
 *
 * This is currently a stub function which displayes a message stating
 * that raster creation is not yet implemented.  Without this function,
 * R would crash if the user attempts to print a raster.
 *
 * This could probably be implemented by writing the raster to an image file,
 * say PNG, and then dropping a node in the MetaP output that contains
 * an \includegraphics directive.
*/
static void MetaP_Raster(
  unsigned int *raster,
  int w, int h,
  double x, double y,
  double width, double height,
  double rot,
  Rboolean interpolate,
  const pGEcontext plotParams, pDevDesc deviceInfo
){

  warning("The MetaPost device does not implement raster images." );
  return R_NilValue;

}

/*
 * From what little documentation exists in GraphicsDevice.h, it is
 * assumed that this function is intended to support capturing a
 * "screen shot" of the current device output and returning it
 * as a raster image.
 *
 * Implementing this functionality would require some careful thought
 * and probably won't happen unless a serious need arises.
 *
 * Argument for implementation: could be useful for "previewing" the 
 * current* state of the tikzDevice output.
*/
static SEXP MetaP_Cap( pDevDesc deviceInfo ){

  warning("The MetaPost device does not currently support capturing device output to a raster image.");
  return R_NilValue;

}


/* 
 * Activate and deactivate execute commands when the active R device is 
 * changed. For devices using plotting windows, these routines usually change 
 * the window title to something like "Active" or "Inactive". Locator is a 
 * routine that is determines coordinates on the plotting canvas corresponding 
 * to a mouse click. For devices plotting to files these functions can be left 
 * as dummy routines.
*/
static void MetaP_Activate( pDevDesc deviceInfo ){}
static void MetaP_Deactivate( pDevDesc deviceInfo ){}
static Rboolean MetaP_Locator( double *x, double *y, pDevDesc deviceInfo ){
  return FALSE;
}

/*
 * The mode function is called when R begins drawing and ends drawing using
 * a device. Currently there are no actions necessary under these conditions
 * so this function is a dummy routine. Conciveably this function could be
 * used to wrap MetaP graphics in \begin{scope} and \end{scope} directives.
*/
static void MetaP_Mode( int mode, pDevDesc deviceInfo ){}
